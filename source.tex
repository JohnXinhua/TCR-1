\documentclass[
	a4paper,
	landscape
	article
]{article}
\usepackage[
	a4paper,
	landscape,
	twocolumn,
	left=0.8cm,
	right=0.5cm,
	vmargin=0.5cm,
	columnsep=1cm
]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[toc]{multitoc}
\usepackage{ifthen}
\usepackage{nicefrac}
\usepackage{hyperref} % for clickable toc and index

% two page landscape layout settings
\renewcommand*{\multicolumntoc}{2}
\setlength{\columnseprule}{0.1pt}
\newcommand{\latexcolumnseprulecolor}{\color{red}}

\usepackage{etoolbox}
\makeatletter
\patchcmd\@outputdblcol{% find
	\normalcolor\vrule
}{% and replace by
	\latexcolumnseprulecolor\vrule
}{% success
}{% failure
	\@latex@warning{Patching \string\@outputdblcol\space failed}%
}
\makeatother
\lstset{
	backgroundcolor=\color{white},
	tabsize=2,
	language=C++,
	basicstyle=\footnotesize\ttfamily,
	frame=lines,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
	showstringspaces=false,
	keywordstyle=\color[rgb]{0, 0, 1},
	commentstyle=\color[rgb]{0, 0.5, 0},
	stringstyle=\color{red}
}

% alle the \vspace are for reducing the vertical spacing
\title{\vspace{-40pt}Team Code Reference\vspace{-0.5em}}
\author{ Timon Knigge, Ragnar Groot Koerkamp, \& Harry Smit }
\date{ \vspace{-0.5em} \today \vspace{-2em} }

% \entry{name}{description}{snippet location}{complexity}{dependencies}
\newcommand{\entry}[5]{
	\subsection{#1}
	#2

	\ifthenelse{\equal{#4}{}}{}{\noindent\textbf{Complexity:} #4}

	\ifthenelse{\equal{#5}{}}{}{\noindent\textbf{Dependencies:} #5}
	\lstinputlisting[language=C++]{#3}
}
\newcommand{\vimentry}[3]{
	\subsection{#1}
	#2
	\lstinputlisting[language=]{#3}
}

% Custom \toc command, to remove the title
\makeatletter
\renewcommand\tableofcontents{%
    \@starttoc{toc}%
}
\makeatother
\begin{document}
% Title without the newpage, see http://tex.stackexchange.com/questions/86249/maketitle-text-before-title
{\let\newpage\relax\maketitle}
\tableofcontents
%\newpage

\section{Vimrc}
% Can't use the \entry command, because filetype is tex
\vimentry{Vimrc}{}
{./snippets/vimrc}

\section{Template}
\entry{C++ Template}{}
{./snippets/header.h}{}{}

\entry{Java Template}{}
{./snippets/template.java}{}{}

\section{Data Structures}

\entry{Union Find}{}
{./snippets/datastructures/unionfind.cpp}{}{}

\entry{Max Queue}
{\texttt{dequeue} runs in amortized constant time. Can be modified to query minimum, gcd/lcm, set union/intersection (use bitmasks), etc.}
{./snippets/datastructures/maxqueue.cpp}{}{}

\entry{Fenwick Tree}
{The tree is 1-based! Use indices $1..n$.}
{./snippets/datastructures/fenwick.cpp}{}{}

\entry{2D Fenwick Tree}
{Can easily be extended to any dimension.}
{./snippets/datastructures/fenwick2d.cpp}{}{}

\entry{Segment Tree}
{The range should be of the form $2^p$.}
{./snippets/datastructures/segmenttree.cpp}{}{}

\entry{Implicit Cartesian Tree}
{The indices are zero-based. Also, don't forget to initialise the empty tree to \texttt{NULL}. (Pretty much) all operations take $O(\log n)$ time.}
{./snippets/datastructures/implicit-cartesian-tree.cpp}{}{}

\entry{AVL Tree}
{Can be augmented to support in $O(\log n)$ time: range queries/updates (similar to a segment tree), insert at position $n$/query for position $n$, order statistics, etc.}
{./snippets/datastructures/avl.cpp}{}{}

\entry{Treap}
{Can be used like the built-in \texttt{set}, except that it also supports order statistics, can be merged/split in $O(\log n)$ time, can support range queries, and more.}
{./snippets/datastructures/treap.cpp}{}{}

\entry{Prefix Trie}{}
{./snippets/datastructures/trie.cpp}{}{}

\entry{Suffix Array}{Note: dont forget to invert the returned array.}
{./snippets/datastructures/suffixarray.cpp}{$O(n \log^2 n)$}{}

\entry{Built-in datastructures}{}
{./snippets/datastructures/builtin.cpp}{}{}

\section{Basic Graph algorithms}

\entry{Edge Classification}{}
{./snippets/graphs/edgeclassification.cpp}
{$O(V + E)$}{}

\entry{Topological sort}{}
{./snippets/graphs/toposort.cpp}
{$O(V + E)$}{}

\entry{Tarjan: SCCs}
{}
{./snippets/graphs/tarjan.cpp}
{$O(V + E)$}
{}

\entry{Biconnected components}
{}
{./snippets/graphs/biconnected_component.cpp}
{$O(V + E)$}
{}

\entry{Kruskal's algorithm}{}
{./snippets/graphs/kruskal.cpp}
{$O(E \log V)$}
{Union Find}

\entry{Prim's algorithm}{}
{./snippets/graphs/prim.cpp}
{$O(E \log V)$}{}

\entry{Dijkstra's algorithm}{}
{./snippets/graphs/dijkstra.cpp}
{$O((V + E) \log V)$}{}

\entry{Bellmann-Ford algorithm}
{Returns \texttt{true} if the graph has no negative cycles.}
{./snippets/graphs/bellmannford.cpp}
{$O(VE)$}{}

\entry{Bellmann-Ford extended}
{An improved (but slower) version of Bellmann-Ford that can indicate for each vertex separately whether it is reachable, and if so, whether there is a lowerbound on the length of the shortest path.}
{./snippets/graphs/bellmannford-extended.cpp}
{$O(VE)$}{}

\entry{Floyd-Warshall algorithm}
{Transitive closure: \texttt{R[a,c] = R[a,c] | (R[a,b] \& R[b,c]))}, transitive reduction: \texttt{R[a,c] = R[a,c] \& !(R[a,b] \& R[b, c]).}}
{./snippets/graphs/floydwarshall.cpp}
{$O(V^3)$}{}

\entry{Hierholzer's algorithm}
{Verify existence of the circuit/trail in advance (see Theorems in Graph Theory for more information). When looking for a trail, be sure to specify the starting vertex.}
{./snippets/graphs/euleriancircuits.cpp}
{$O(V + E)$}{}

\entry{Bron-Kerbosch}
{Count the number of maximal cliques in a graph with up to a few hundred nodes.}
{./snippets/graphs/bronkerbosch.cpp}
{$O(3^{\nicefrac n3})$}{}


\subsection{Theorems in Graph Theory}
\begin{description}
	\item[Dilworth's theorem]:
		The minimum number of disjoint chains into which S can be decomposed equals the length of a longest antichain of S.

		Compute by defining a bipartite graph with a source $u_x$ and sink $v_x$ for each vertex $x$, and adding an edge $(u_x, v_y)$ if $x \leq y, x \neq y$. Let $m$ denote the size of the maximum matching, then the number of disjoint chains is $|S| - m$ (the collection of unmatched endpoints).

	\item[Mirsky's theorem]:
		The minimum number of disjoint antichains into which S can be decomposed equals the length of a longest chain of S.

		Compute by defining $L_v$ to be the length of the longest chain ending at $v$. Sort $S$ topologically and use bottom-up DP to compute $L_u$ for all $u \in S$.

	\item[Kirchhoff's theorem]:
		Define a $V \times V$ matrix $M$ as: $M_{ij} = deg(i)$ if $i == j$, $M_{ij} = - 1$ if $\{i, j\} \in E$, $M_{ij} = 0$ otherwise. Then the number of distinct spanning trees equals any minor of $M$.

	\item[Acyclicity]:
		A directed graph is acyclic if and only if a depth-first search yields no back edges.

	\item[Euler Circuits and Trails]:
		In an \textit{undirected graph}, an \textit{Eulerian Circuit} exists if and only if all vertices have even degree, and all vertices of nonzero degree belong to a single connected component. In an \textit{undirected graph}, an \textit{Eulerian Trail} exists if and only if at most two vertices have odd degree, and all of its vertices of nonzero degree belong to a single connected component. In a \textit{directed graph}, an \textit{Eulerian Circuit} exists if and only if every vertex has equal indegree and outdegree, and all vertices of nonzero degree belong to a single strongly connected component. In a \textit{directed graph}, an \textit{Eulerian Trail} exists if and only at most one vertex has $outdegree - indegree = 1$, at most one vertex has $indegree - outdegree = 1$, every other vertex has equal indegree and outdegree, and all vertices of nonzero degree belong to a single strongly connected component \textit{in the underlying undirected graph}.
\end{description}

\entry{Centroid Decomposition}
{In case it is necessary to work with the subtrees directly, consider timestamping each node during the decomposition}
{./snippets/graphs/centroid.cpp}
{$O(n \log n)$}{}

\entry{Heavy-Light decomposition}
{}
{./snippets/graphs/heavylight.cpp}
{$O(n)$}{}

\section{Flow and Matching}

\entry{Flow Network}
{Generic flow network used by the algorithms in this section. Should not require any modifications. \emph{Note:} Get the reverse of \texttt{e[i]} as \texttt{e[i \textasciicircum  1]}. Don't forget to \texttt{cleanup()} afterwards.}
{./snippets/flowalgorithms/flownetwork.cpp}{}{}

\entry{Edmonds-Karp algorithm}{}
{./snippets/flowalgorithms/edmondskarp.cpp}
{$O(VE^2)$}
{Flow Network}

\entry{Dinic's algorithm}{}
{./snippets/flowalgorithms/dinic.cpp}
{$O(V^2E)$}
{Flow Network}

\entry{Minimum Cut Inference}
{The maximum flow equals the minimum cut. Only use this if the specific edges are needed. Run a flow algorithm in advance.}
{./snippets/flowalgorithms/infermincut.cpp}
{$O(V + E)$}
{Flow Network}

\entry{Flow Graph}
{Structure used by the following flow algorithms.}
{./snippets/flowalgorithms/flowgraph.cpp}{}{}

\entry{Dinic Ragnar}{}
{./snippets/flowalgorithms/dinic_ragnar.cpp}
{$O(V^2E)$}
{Flow Graph}

\entry{Edmonds Karp Ragnar}{}
{./snippets/flowalgorithms/edmondskarp_ragnar.cpp}
{$O(VE^2)$}
{Flow Graph}

\entry{Edmonds Karp (Dijkstra)}{}
{./snippets/flowalgorithms/edmonds_karp_dijkstra_ragnar.cpp}
{}
{Flow Graph}

\entry{Push Relabel Ragnar}{}
{./snippets/flowalgorithms/push_relabel.cpp}
{}
{Flow Graph}

\entry{Hopcroft Karp Ragnar}{}
{./snippets/flowalgorithms/hopcroft_karp_ragnar.cpp}
{}
{Flow Graph}

% \& crashes pdf-viewer index generator. Something due to hyperref (working at Ragnar's pc)
% \& needed to make the toc entry 1 line
\section{Combinatorics \& Probability}

\entry{Stable Marriage Problem}
{If $m = w$, the algorithm finds a complete, optimal matching. \texttt{mpref[i][j]} gives the id of the j'th preference of the i'th man. \texttt{wpref[i][j]} gives the preference the j'th woman assigns to the i'th man. Both \texttt{mpref} and \texttt{wpref} should be zero-based permutations.}
{./snippets/combinatorics/stablemarriage.cpp}
{$O(mw)$}{}

\entry{Meet in the Middle}
{Sufficient for $2 \leq n \leq 14$.}
{./snippets/combinatorics/meetinthemiddle.cpp}
{$O(n^2\binom{n}
	{n/2}\big(\frac{n}
{2}\big)!)$}{}

\entry{KP procedure}
{Solves a two variable single constraint integer linear programming problem. It can be extended to an arbitrary number of constraints by inductively decomposing the constrained region into its binding constraints (hence the $L$ and $U$), and solving for each region.}
{./snippets/combinatorics/twovariablesilp.cpp}
{$O(d^2 log(d)log(log(d)))$}{}

\entry{2-SAT}{}
{./snippets/combinatorics/2-sat.cpp}
{$O(|\text{variables}|+|\text{implications}|)$}
{Tarjan's}

\section{Computational geometry}

\entry{Essentials}{}
{./snippets/geometry/geometryessentials.cpp}{}{}

\entry{Essentials, Ragnar}{}
{./snippets/geometry/basics_ragnar.cpp}{}
{}

\entry{Convex Hull}{}
{./snippets/geometry/convexhull.cpp}
{$O(n \log n)$}
{Geometry Essentials}

\entry{Polygon}{}
{./snippets/geometry/polygon.cpp}{}
{Geometry Essentials}

\section{Mathematics}

\entry{Primes}{}
{./snippets/mathematics/primes.cpp}{}{}

\entry{Number theoretic algorithms}{}
{./snippets/mathematics/numbertheory.cpp}{}{}

\entry{Lucas' theorem}{}
{./snippets/mathematics/lucas.cpp}{}{}

\entry{Complex Numbers}
{Faster-than-built-in complex numbers}
{./snippets/mathematics/complex.cpp}{}{}

\entry{Fast Fourier Transform}
{Calculates the discrete convolution of two vectors. Note that the method accepts and outputs complex numbers, and the input is changed in place.}
{./snippets/mathematics/fft.cpp}
{$O(n \log n)$}
{Bitmasking, Complex Numbers}

\entry{Matrix equation solver}
{Solve $xM=a$ for $x$, and write $M$ in reduced row echelon form, where each row starts with a $1$, and this $1$ is the only nonzero value in its column.}
{./snippets/mathematics/reduced_row_echelon.cpp}{}{}

\entry{Matrix Exponentation}
{Matrix exponentation in logarithmic time.}
{./snippets/mathematics/matrixexponentation.cpp}{}{}

\section{Strings}

\entry{Knuth Morris Pratt}{}
{./snippets/strings/knuthmorrispratt.cpp}
{$O(n + m)$}{}

\entry{Z-algorithm}
{To match pattern $P$ on string $S$: pick $\Phi$ s.t. $\Phi \notin P$, find $Z$ of $P{\Phi}S$.}
{./snippets/strings/zalgorithm.cpp}
{$O(n)$}{}

\entry{Aho-Corasick}
{Constructs a Finite State Automaton that can match $k$ patterns of total length $m$ on a string of size $n$.}
{./snippets/strings/ahocorasick.cpp}
{$O(n + m + k)$}{}

\section{Miscellaneous}

\entry{Longest Increasing Subsequence}
{Finds the longest strictly increasing subsequence. To find the longest non-decreasing subsequence, insert pairs $(a_i, i)$. Note that the elements should be totally ordered. To find the LIS of a sequence of elements from a partially ordered set (e.g. coordinates in the plane), replace \texttt{lis[]} with a set of equivalent elements, at a cost of another $O(\log n)$ factor.}
{./snippets/misc/lis.cpp}
{$O(n \log n)$}{}

\entry{Randomisation}{Might be useful for NP-Complete/Backtracking problems}
{./snippets/misc/randomisation.cpp}{}{}

\section{Helpers}

\entry{Golden Section Search}
{For a discrete search: use binary search on the difference of successive elements, see the section on Binary Search.}
{./snippets/helpers/goldensectionsearch.cpp}
{$O(\log {1 / \epsilon})$}{}

\entry{Binary Search}{}
{./snippets/helpers/binarysearch.cpp}
{$O(\log n), O(\log {1 / \epsilon})$}{}

\entry{Bitmasking}{}
{./snippets/helpers/bitmasking.cpp}{}{}

\entry{QuickSelect}
{Running time is expected, quadratic in the worst case. Alternatingly breaks ties left and right, so it should be pretty resilient to edge cases. Note that the vector is changed in the process. Recursion depth is $O(\log n)$.}
{./snippets/helpers/quickselect.cpp}
{$O(n)$}{}

\entry{Fast IO}{}{./snippets/helpers/fastinput.cpp}{}{}

\end{document}
