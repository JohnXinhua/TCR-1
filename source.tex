\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage[margin=1in]{geometry}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[toc]{multitoc}
\usepackage{ifthen}

\renewcommand*{\multicolumntoc}{2}
\setlength{\columnseprule}{0.5pt}

\lstset{
    backgroundcolor=\color{white},
    tabsize=3,
    language=C++,
    basicstyle=\footnotesize\ttfamily,
    frame=lines,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    keywordstyle=\color[rgb]{0, 0, 1},
    commentstyle=\color[rgb]{0, 0.5, 0},
    stringstyle=\color{red}    
}

\definecolor{usertype}{RGB}{43,145,175}
\definecolor{macro}{RGB}{111,0,138}
\lstset{emph=[1]{pair,vector,map,queue,priority\_queue,greater,
                 stack,ii,vi,vvi,vii,vvii,vb,ll,ld,UnionFind,
                 coord,point,line,LineType,bitset,size\_t,
                 FlowNetwork,edge,string,FenwickTree,
                 FenwickTree2D,MaxQueue,Matrix,cmpx,complex},
        emphstyle=[1]{\color{usertype}},
        emph=[2]{INF,LLINF,EPSILON,RES\_PHI,\_MSC\_VER,
		        popcount,MAXV,ITERATE\_MATRIX,M\_PI,
                \_USE\_MATH\_DEFINES,LDINF,MY\_PI},
        emphstyle=[2]{\color{macro}},
        emph=[3]{nullptr},
        emphstyle=[3]{\color{blue}}}

\title{Team Code Reference}
\author{
    Timon Knigge
}

% \entry{name}{description}{snippet location}{complexity}{dependencies}
\newcommand{\entry}[5]{
    \subsection{#1}
    #2
    
    \ifthenelse{\equal{#4}{}}{}{\noindent\textbf{Complexity:} #4}
    
    \ifthenelse{\equal{#5}{}}{}{\noindent\textbf{Dependencies:} #5}
    \lstinputlisting[language=C++]{#3}
}

\begin{document}
  \maketitle
  \tableofcontents
  \clearpage
    
  \section{Template}
    \entry{C++ Template}{}{snippets/header.h}{}{}
    \todo{Fix includes}
    \subsection{Java Template*}
    
  \section{Data Structures}
    
    \entry{Union Find}{}{snippets/datastructures/unionfind.cpp}{}{}
    \todo{Revise UF, compare with existing implementations.}
    
    \entry{Max Queue}{\texttt{dequeue} runs in amortized constant time. Can be modified to query minimum, gcd/lcm, set union/intersection (use bitmasks), etc.}{snippets/datastructures/maxqueue.cpp}{}{}
    
    \entry{Fenwick Tree}{The tree is 1-based! Use indices $1..n$.}{snippets/datastructures/fenwick.cpp}{}{}
    \todo{Add inverse Fenwick Tree}
    
    \entry{2D Fenwick Tree}{Can easily be extended to any dimension.}{snippets/datastructures/fenwick2d.cpp}{}{}
    
    \subsection{Sparse table*}    
    
    \subsection{Range Minimum Query*}
    
    \subsection{Segment tree*}
    
	\entry{Prefix Trie}{}{snippets/datastructures/trie.cpp}{}{}
    
    \subsection{Suffix array*}
    
    \subsection{Heavy-Light decomposition*}
    
    \subsection{Pareto Front*}
    
  \section{Basic Graph algorithms}
     
    \entry{Edge Classification}{}{snippets/graphs/edgeclassification.cpp}{$O(V + E)$}{}
    
    \subsection{Articulation points and bridges*}
    
    \entry{Topological sort}{}{snippets/graphs/toposort.cpp}{$O(V + E)$}{}
    
    \entry{Kruskal's algorithm}{}{snippets/graphs/kruskal.cpp}{$O(E \log_2 V)$}{Union Find}
    
    \entry{Prim's algorithm}{}{snippets/graphs/prim.cpp}{$O(E \log_2 V)$}{}
    
    \subsection{Biconnected components*}
    
    \subsection{Strongly connected components*}
    
    \subsection{Kosaraju's algorithm*}
    
    \entry{Dijkstra's algorithm}{}{snippets/graphs/dijkstra.cpp}{$O((V + E) \log_2 V)$}{}
    
    \entry{Bellmann-Ford algorithm}{There exists a negative cycle if we can relax a weight in a $V$'th iteration.}{snippets/graphs/bellmannford.cpp}{$O(VE)$}{}
    
    \entry{Floyd-Warshall algorithm}{Transitive closure: \texttt{R[a,c] = R[a,c] | (R[a,b] \& R[b,c]))}, transitive reduction: \texttt{R[a,c] = R[a,c] \& !(R[a,b] \& R[b, c]).}}{snippets/graphs/floydwarshall.cpp}{$O(V^3)$}{}
        
    \subsection{Fleury's algorithm*}
    
    \subsection{Theorems in Graph Theory}
    \begin{description}
        \item[Dilworth's theorem]: The minimum number of disjoint chains into which S can be decomposed equals the length of a longest antichain of S.
        
        Compute by defining a bipartite graph with a source $u_x$ and sink $v_x$ for each vertex $x$, and adding an edge $(u_x, v_y)$ if $x \leq y, x \neq y$. Let $m$ denote the size of the maximum matching, then the number of disjoint chains is $|S| - m$ (the collection of unmatched endpoints).
        
        \item[Mirsky's theorem]: The minimum number of disjoint antichains into which S can be decomposed equals the length of a longest chain of S.
        
        Compute by defining $L_v$ to be the length of the longest chain ending at $v$. Sort $S$ topologically and use bottom-up DP to compute $L_u$ for all $u \in S$.
        
        \item[Kirchhoff's theorem]: Define a $V \times V$ matrix $M$ as: $M_{ij} = deg(i)$ if $i == j$, $M_{ij} = - 1$ if $\{i, j\} \in E$, $M_{ij} = 0$ otherwise. Then the number of distinct spanning trees equals any minor of $M$.
        
        \item[Acyclicity]: A directed graph is acyclic if and only if a depth-first search yields no back edges.
    \end{description}
    
  \section{Flow Algorithms}
  
    \entry{Flow Network}{Generic flow network used by the algorithms in this section. Should not require any modifications. \emph{Note:} Get the reverse of \texttt{e[i]} as \texttt{e[i \textasciicircum  1]}. Don't forget to \texttt{cleanup()} afterwards.}{snippets/flowalgorithms/flownetwork.cpp}{}{}
  
    \entry{Edmonds-Karp algorithm}{}{snippets/flowalgorithms/edmondskarp.cpp}{$O(VE^2)$}{Flow Network}
  
    \subsection{Dinic's algorithm*}
  
    \subsection{Push-relabel algorithm*}
    
    \entry{Minimum Cut Inference}{The maximum flow equals the minimum cut. Only use this if the specific edges are needed. Run a flow algorithm in advance.}{snippets/flowalgorithms/infermincut.cpp}{$O(V + E)$}{Flow Network}
        
  \section{Combinatorics \& Probability}
  
    \subsection{Essentials*}
  
    \subsection{Hopcroft-Karp algorithm*}
    
    \subsection{Hungarian algorithm*}
    
    \entry{Stable Marriage Problem}{If $m = w$, the algorithm finds a complete, optimal matching. \texttt{mpref[i][j]} gives the id of the j'th preference of the i'th man. \texttt{wpref[i][j]} gives the preference the j'th woman assigns to the i'th man. Both \texttt{mpref} and \texttt{wpref} should be zero-based permutations.}{snippets/combinatorics/stablemarriage.cpp}{$O(mw)$}{}
    
	\entry{Meet in the Middle}{Sufficient for $2 \leq n \leq 14$.}{snippets/combinatorics/meetinthemiddle.cpp}{$O(n^2\binom{n}{n/2}\big(\frac{n}{2}\big)!)$}{}
	
	\entry{KP procedure}{Solves a two variable single constraint integer linear programming problem. It can be extended to an arbitrary number of constraints by inductively decomposing the constrained region into its binding constraints (hence the $L$ and $U$), and solving for each region.}{snippets/combinatorics/twovariablesilp.cpp}{$O(d^2 log_2(d)log_2(log_2(d)))$}{}
    
    \subsection{2-SAT*}
    
  \section{Computational geometry}
    
    \entry{Essentials}{}{snippets/geometry/geometryessentials.cpp}{}{}
    \todo{Add numerically stable line intersection check.}
    
    \entry{Convex Hull}{}{snippets/geometry/convexhull.cpp}{$O(n \log_2 n)$}{Geometry Essentials}
    \todo{Revise, consider existing implementations}
    
    \subsection{Halfspace intersections*}
    
  \section{Mathematics}
    
    \entry{Primes}{}{snippets/mathematics/primes.cpp}{}{}
    \todo{Rewrite Totient function}
    
    \entry{Number theoretic algorithms}{}{snippets/mathematics/numbertheory.cpp}{}{}
    
    \entry{Complex Numbers}{Faster-than-built-in complex numbers}{snippets/mathematics/complex.cpp}{}{}
    
    \entry{Fast Fourier Transform}{Calculates the discrete convolution of two vectors. Note that the method accepts and outputs complex numbers, and the input is changed in place.}{snippets/mathematics/fft.cpp}{$O(n \log_2 n)$}{Bitmasking, Complex Numbers}
    
    \subsection{BigInteger*}
    
    \entry{Matrix Exponentation}{Matrix exponentation in logarithmic time.}{snippets/mathematics/matrixexponentation.cpp}{}{}
        
  \section{Strings}
  
    \entry{Knuth Morris Pratt}{}{snippets/strings/knuthmorrispratt.cpp}{$O(n + m)$}{}
    
    \entry{Z-algorithm}{To match pattern $P$ on string $S$: pick $\Phi$ s.t. $\Phi \notin P$, find $Z$ of $P{\Phi}S$.}{snippets/strings/zalgorithm.cpp}{$O(n)$}{}
    
  \section{Helpers}
  
    \entry{Golden Section Search}{}{snippets/helpers/goldensectionsearch.cpp}{$O(\log_2 {1 / \epsilon})$}{}
    \todo{Write integer search}
    
    \entry{Binary Search}{}{snippets/helpers/binarysearch.cpp}{$O(\log_2 n), O(\log_2 {1 / \epsilon})$}{}
    
    \entry{Bitmasking}{}{snippets/helpers/bitmasking.cpp}{}{}
    
	\entry{QuickSelect}{Running time is expected, quadratic in the worst case. Alternatingly breaks ties left and right, so it should be pretty resilient to edge cases. Note that the vector is changed in the process. Recursion depth is $O(\log_2 n)$.}{snippets/helpers/quickselect.cpp}{$O(n)$}{}
    
\end{document}
