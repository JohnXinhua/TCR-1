\documentclass[
	a4paper,
	landscape
	twocolumn
]{article}
\usepackage[
	a4paper,
	landscape,
	twocolumn,
	left=0.8cm,
	right=0.5cm,
	vmargin=0.5cm,
	columnsep=1cm
]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[toc]{multitoc}
\usepackage{ifthen}

\renewcommand*{\multicolumntoc}{2}
\setlength{\columnseprule}{0.1pt}
\newcommand{\latexcolumnseprulecolor}{\color{red}}

\usepackage{etoolbox}
\makeatletter
\patchcmd\@outputdblcol{% find
  \normalcolor\vrule
}{% and replace by
  \latexcolumnseprulecolor\vrule
}{% success
}{% failure
  \@latex@warning{Patching \string\@outputdblcol\space failed}%
}
\makeatother
\lstset{
    backgroundcolor=\color{white},
    tabsize=2,
    language=C++,
    basicstyle=\footnotesize\ttfamily,
    frame=lines,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    keywordstyle=\color[rgb]{0, 0, 1},
    commentstyle=\color[rgb]{0, 0.5, 0},
    stringstyle=\color{red}
}

\title{Team Code Reference}
\author{
    Timon Knigge
}

% \entry{name}{description}{snippet location}{complexity}{dependencies}
\newcommand{\entry}[5]{
    \subsection{#1}
    #2

    \ifthenelse{\equal{#4}{}}{}{\noindent\textbf{Complexity:} #4}

    \ifthenelse{\equal{#5}{}}{}{\noindent\textbf{Dependencies:} #5}
    \lstinputlisting[language=C++]{#3}
}
\newcommand{\vimentry}[5]{
    \subsection{#1}
    #2

    \ifthenelse{\equal{#4}{}}{}{\noindent\textbf{Complexity:} #4}

    \ifthenelse{\equal{#5}{}}{}{\noindent\textbf{Dependencies:} #5}
    \lstinputlisting[language=]{#3}
}

\begin{document}
{\Large Team Code Reference}
  \tableofcontents
  \newpage

  \section{Vimrc}
  % Can't use the \entry command, because filetype is tex
  \vimentry{Vimrc}{}{./snippets/vimrc}{}{}

  \section{Template}
  \entry{C++ Template}{}{snippets/header.h}{}{}

  \section{Data Structures}

    \entry{Union Find}{}{snippets/datastructures/unionfind.cpp}{}{}

    \entry{Max Queue}{\texttt{dequeue} runs in amortized constant time. Can be modified to query minimum, gcd/lcm, set union/intersection (use bitmasks), etc.}{snippets/datastructures/maxqueue.cpp}{}{}

    \entry{Fenwick Tree}{The tree is 1-based! Use indices $1..n$.}{snippets/datastructures/fenwick.cpp}{}{}

    \entry{2D Fenwick Tree}{Can easily be extended to any dimension.}{snippets/datastructures/fenwick2d.cpp}{}{}

    \entry{Segment Tree}{The range should be of the form $2^p$.}{snippets/datastructures/segmenttree.cpp}{}{}

    \entry{AVL Tree}{Can be augmented to support in $O(\log_2 n)$ time: range queries/updates (similar to a segment tree), insert at position $n$/query for position $n$, order statistics, etc.}{snippets/datastructures/avl.cpp}{}{}

    \entry{Prefix Trie}{}{snippets/datastructures/trie.cpp}{}{}

    \entry{Built-in datastructures}{}{snippets/datastructures/builtin.cpp}{}{}

  \section{Basic Graph algorithms}

    \entry{Edge Classification}{}{snippets/graphs/edgeclassification.cpp}{$O(V + E)$}{}

    \entry{Topological sort}{}{snippets/graphs/toposort.cpp}{$O(V + E)$}{}

    \entry{Tarjan: strongly connected components}
	{}
	{snippets/graphs/tarjan.cpp}
	{$O(V + E)$}
	{}

    \entry{Kruskal's algorithm}{}{snippets/graphs/kruskal.cpp}{$O(E \log_2 V)$}{Union Find}

    \entry{Prim's algorithm}{}{snippets/graphs/prim.cpp}{$O(E \log_2 V)$}{}

    \entry{Dijkstra's algorithm}{}{snippets/graphs/dijkstra.cpp}{$O((V + E) \log_2 V)$}{}

    \entry{Bellmann-Ford algorithm}{Returns \texttt{true} if the graph has no negative cycles.}{snippets/graphs/bellmannford.cpp}{$O(VE)$}{}

    \entry{Floyd-Warshall algorithm}{Transitive closure: \texttt{R[a,c] = R[a,c] | (R[a,b] \& R[b,c]))}, transitive reduction: \texttt{R[a,c] = R[a,c] \& !(R[a,b] \& R[b, c]).}}{snippets/graphs/floydwarshall.cpp}{$O(V^3)$}{}

    \entry{Hierholzer's algorithm}{Verify existence of the circuit/trail in advance (see Theorems in Graph Theory for more information). When looking for a trail, be sure to specify the starting vertex.}{snippets/graphs/euleriancircuits.cpp}{$O(V + E)$}{}

    \subsection{Theorems in Graph Theory}
    \begin{description}
        \item[Dilworth's theorem]: The minimum number of disjoint chains into which S can be decomposed equals the length of a longest antichain of S.

        Compute by defining a bipartite graph with a source $u_x$ and sink $v_x$ for each vertex $x$, and adding an edge $(u_x, v_y)$ if $x \leq y, x \neq y$. Let $m$ denote the size of the maximum matching, then the number of disjoint chains is $|S| - m$ (the collection of unmatched endpoints).

        \item[Mirsky's theorem]: The minimum number of disjoint antichains into which S can be decomposed equals the length of a longest chain of S.

        Compute by defining $L_v$ to be the length of the longest chain ending at $v$. Sort $S$ topologically and use bottom-up DP to compute $L_u$ for all $u \in S$.

        \item[Kirchhoff's theorem]: Define a $V \times V$ matrix $M$ as: $M_{ij} = deg(i)$ if $i == j$, $M_{ij} = - 1$ if $\{i, j\} \in E$, $M_{ij} = 0$ otherwise. Then the number of distinct spanning trees equals any minor of $M$.

        \item[Acyclicity]: A directed graph is acyclic if and only if a depth-first search yields no back edges.

        \item[Euler Circuits and Trails]: In an \textit{undirected graph}, an \textit{Eulerian Circuit} exists if and only if all vertices have even degree, and all vertices of nonzero degree belong to a single connected component. In an \textit{undirected graph}, an \textit{Eulerian Trail} exists if and only if at most two vertices have odd degree, and all of its vertices of nonzero degree belong to a single connected component. In a \textit{directed graph}, an \textit{Eulerian Circuit} exists if and only if every vertex has equal indegree and outdegree, and all vertices of nonzero degree belong to a single strongly connected component. In a \textit{directed graph}, an \textit{Eulerian Trail} exists if and only at most one vertex has $outdegree - indegree = 1$, at most one vertex has $indegree - outdegree = 1$, every other vertex has equal indegree and outdegree, and all vertices of nonzero degree belong to a single strongly connected component \textit{in the underlying undirected graph}.
    \end{description}

  \section{Flow and Matching Algorithms}

    \entry{Flow Network}{Generic flow network used by the algorithms in this section. Should not require any modifications. \emph{Note:} Get the reverse of \texttt{e[i]} as \texttt{e[i \textasciicircum  1]}. Don't forget to \texttt{cleanup()} afterwards.}{snippets/flowalgorithms/flownetwork.cpp}{}{}

    \entry{Edmonds-Karp algorithm}{}{snippets/flowalgorithms/edmondskarp.cpp}{$O(VE^2)$}{Flow Network}

    \entry{Dinic's algorithm}{}{snippets/flowalgorithms/dinic.cpp}{$O(V^2E)$}{Flow Network}

    \entry{Minimum Cut Inference}{The maximum flow equals the minimum cut. Only use this if the specific edges are needed. Run a flow algorithm in advance.}{snippets/flowalgorithms/infermincut.cpp}{$O(V + E)$}{Flow Network}

  \section{Combinatorics \& Probability}

    \entry{Stable Marriage Problem}{If $m = w$, the algorithm finds a complete, optimal matching. \texttt{mpref[i][j]} gives the id of the j'th preference of the i'th man. \texttt{wpref[i][j]} gives the preference the j'th woman assigns to the i'th man. Both \texttt{mpref} and \texttt{wpref} should be zero-based permutations.}{snippets/combinatorics/stablemarriage.cpp}{$O(mw)$}{}

    \entry{Meet in the Middle}{Sufficient for $2 \leq n \leq 14$.}{snippets/combinatorics/meetinthemiddle.cpp}{$O(n^2\binom{n}{n/2}\big(\frac{n}{2}\big)!)$}{}
	
    \entry{KP procedure}{Solves a two variable single constraint integer linear programming problem. It can be extended to an arbitrary number of constraints by inductively decomposing the constrained region into its binding constraints (hence the $L$ and $U$), and solving for each region.}{snippets/combinatorics/twovariablesilp.cpp}{$O(d^2 log_2(d)log_2(log_2(d)))$}{}

    \entry{2-SAT}{}{snippets/combinatorics/2-sat.cpp}{$O(|\text{variables}|+|\text{implications}|)$}{Tarjan's}

  \section{Computational geometry}

    \entry{Essentials}{}{snippets/geometry/geometryessentials.cpp}{}{}

    \entry{Convex Hull}{}{snippets/geometry/convexhull.cpp}{$O(n \log_2 n)$}{Geometry Essentials}

  \section{Mathematics}

    \entry{Primes}{}{snippets/mathematics/primes.cpp}{}{}

    \entry{Number theoretic algorithms}{}{snippets/mathematics/numbertheory.cpp}{}{}

    \entry{Complex Numbers}{Faster-than-built-in complex numbers}{snippets/mathematics/complex.cpp}{}{}

    \entry{Fast Fourier Transform}{Calculates the discrete convolution of two vectors. Note that the method accepts and outputs complex numbers, and the input is changed in place.}{snippets/mathematics/fft.cpp}{$O(n \log_2 n)$}{Bitmasking, Complex Numbers}

    \entry{Matrix Exponentation}{Matrix exponentation in logarithmic time.}{snippets/mathematics/matrixexponentation.cpp}{}{}

  \section{Strings}

    \entry{Knuth Morris Pratt}{}{snippets/strings/knuthmorrispratt.cpp}{$O(n + m)$}{}

    \entry{Z-algorithm}{To match pattern $P$ on string $S$: pick $\Phi$ s.t. $\Phi \notin P$, find $Z$ of $P{\Phi}S$.}{snippets/strings/zalgorithm.cpp}{$O(n)$}{}

    \entry{Aho-Corasick}{Constructs a Finite State Automaton that can match $k$ patterns of total length $m$ on a string of size $n$.}{snippets/strings/ahocorasick.cpp}{$O(n + m + k)$}{}

  \section{Miscellaneous}

    \entry{Longest Increasing Subsequence}{Finds the longest strictly increasing subsequence. To find the longest non-decreasing subsequence, insert pairs $(a_i, i)$. Note that the elements should be totally ordered. To find the LIS of a sequence of elements from a partially ordered set (e.g. coordinates in the plane), replace \texttt{lis[]} with a set of equivalent elements, at a cost of another $O(\log_2 n)$ factor.}{snippets/misc/lis.cpp}{$O(n \log_2 n)$}{}

  \section{Helpers}

    \entry{Golden Section Search}{For a discrete search: use binary search on the difference of successive elements, see the section on Binary Search.}{snippets/helpers/goldensectionsearch.cpp}{$O(\log_2 {1 / \epsilon})$}{}

    \entry{Binary Search}{}{snippets/helpers/binarysearch.cpp}{$O(\log_2 n), O(\log_2 {1 / \epsilon})$}{}

    \entry{Bitmasking}{}{snippets/helpers/bitmasking.cpp}{}{}

    \entry{QuickSelect}{Running time is expected, quadratic in the worst case. Alternatingly breaks ties left and right, so it should be pretty resilient to edge cases. Note that the vector is changed in the process. Recursion depth is $O(\log_2 n)$.}{snippets/helpers/quickselect.cpp}{$O(n)$}{}

\end{document}
