\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage[margin=1in]{geometry}
\usepackage[colorinlistoftodos]{todonotes}

\lstset{
	backgroundcolor=\color{white},
	tabsize=3,
	language=C++,
	basicstyle=\footnotesize\ttfamily,
	frame=lines,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
	showstringspaces=false,
	keywordstyle=\color[rgb]{0, 0, 1},
	commentstyle=\color[rgb]{0, 0.5, 0},
	stringstyle=\color{red}	
}

\title{Team Code Reference}
\author{
	Timon Knigge
}

\begin{document}
	\maketitle
	\tableofcontents
	\clearpage
	
	\section{Template}
	
	\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <bitset>
#include <algorithm>
#include <functional>
#include <string>
#include <math.h>

using namespace std;

typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ii> vii;
typedef vector<vii> vvii;
typedef long long ll;

int main(){
	int T;
	scanf("%d", &T);
	
	for(int t = 1; t <= T; ++t){
		// solve
	}
	
	return 0;
}
	\end{lstlisting}
	
	\section{Data Structures}
	
	\subsection{Union Find}
	
	\begin{lstlisting}
vii pset;
int psets;

class UnionFind {
private:
	vi parent, rank, setSize;
	int setCount;
public:
	UnionFind(int N) {
		setSize.assign(N, 1);
		setCount = N;
		rank.assign(N, 0);
		parent.assign(N, 0);
		
		for (int i = 0; i < N; ++i) parent[i] = i;
	}
	
	int findSet(int i) {
		return (parent[i] == i) ? i : (parent[i] = findSet(parent[i]));
	}
	
	bool areSameSet(int i, int j) {
		return (findSet(i) == findSet(j));
	}
	
	void unionSet(int i, int j) {
		if (areSameSet(i, j)) return;
		setCount--;
		int pi = findSet(i), pj = findSet(j);
		if (rank[pi] > rank[pj]) {
			parent[pj] = pi;
			setSize[pi] += setSize[pj];
		} else {
			parent[pi] = pj;
			setSize[pj] += setSize[pi];
			if (rank[pi] == rank[pj])) rank[pj]++;
		}
	}
}
	\end{lstlisting}
	
	\subsection{Sparse table}
	\subsection{Segment tree}
	\subsection{Suffix tree}
	\section{Graph algorithms}
	\subsection{DFS}
	\subsection{BFS}
	\subsection{Edge classification}
	\subsection{Topological sort}
	\subsection{Floodfill}
	\subsection{Kruskal's algorithm}
	\subsection{Biconnected components}
	\subsection{Strongly connected components}
	\subsection{Dijkstra's algorithm}
	\subsection{Bellmann-Ford algorithm}
	\subsection{Floyd-Warshall algorithm}
	\subsection{Edmonds-Karp algorithm}
	\subsection{Fleury's algorithm}
	\subsection{Hopcroft-Karp algorithm}
	\subsection{Hungarian algorithm}
	\section{Computational geometry}
	\subsection{Essentials}
	\subsection{Polygons}
	\subsection{Convex Hull}
	\subsection{Halfspace intersections}
	\section{Mathematics}
	\subsection{Primes}
	\subsection{Modular arithmetic}
	\subsection{Diophantine equations}
	\subsection{BigInteger}
	\subsection{Fast matric multiplication}
	\section{Strings}
	\subsection{KMP string matching}
	\section{Helpers}
	\subsection{Golden section search}
	\begin{lstlisting}
#define RES_PHI (2 - ((1.0 + sqrt(5)) / 2.0))
#define EPSILON 1e-7

double gss(double (*f)(double), double leftbound, double rightbound) {
	double lb = leftbound, rb = rightbound, mlb = lb + RES_PHI * (rb - lb), mrb = rb + RES_PHI * (lb - rb);
	double lbv = f(lb), rbv = f(rb), mlbv = f(mlb), mrbv = f(mrb);
	
	while (rb - lb >= EPSILON) { // || abs(rbv - lbv) >= EPSILON) {
		if (mlbv < mrbv) { // > to maximize
			rb  = mrb;  rbv  = mrbv;
			mrb = mlb;  mrbv = mlbv;
			mlb = lb + RES_PHI * (rb - lb);
			mlbv = f(mlb);
		} else {
			lb  = mlb;  lbv  = mlbv;
			mlb = mrb;  mlbv = mrbv;
			mrb = rb + RES_PHI * (lb - rb);
			mrbv = f(mrb);
		}
	}
	return mlb; // any bound should do
}
	\end{lstlisting}
	\subsection{Integer ternary search}
	\subsection{Bitmasking}
	
	\begin{lstlisting}
#ifdef _MSC_VER
#define popcount(x) __popcnt(x)
#else
#define popcount(x) __builtin_popcount(x)
#endif

bool bitSet(int mask, int pos) {
	return ((mask & (1 << pos)) != 0);
}

// Iterate over all subsets of a set of size N
for (int mask = 0; mask < (1 << N); ++mask) {
	// Decode mask here
}

// Iterate over all k-subsets of a set of size N
int mask = (1 << k) - 1;
while (!(mask & 1 << N)) {
	// Decode mask here
	int lo = mask & ~(mask - 1);
	int lz = (mask + lo) & ~mask;
	mask |= lz;
	mask &= ~(lz - 1);
	mask |= (lz / lo / 2) - 1;
}

// Iterate over all subsets of a subset
int mask = givenMask;
do {
	// Decode mask here
	mask = (mask - 1) & givenMask;
} while (mask != givenMask);
	\end{lstlisting}
\end{document}